<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>series-study on Wxf`s Fantasy World</title>
    <link>/tags/series-study/</link>
    <description>Recent content in series-study on Wxf`s Fantasy World</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 21 May 2025 11:10:50 +0800</lastBuildDate>
    <atom:link href="/tags/series-study/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Do</title>
      <link>/resource/do/</link>
      <pubDate>Wed, 21 May 2025 11:10:50 +0800</pubDate>
      <guid>/resource/do/</guid>
      <description>do，遇到不会的再想办法解决，that`s core!&#xA;end this topic!</description>
    </item>
    <item>
      <title>技能习得与提升</title>
      <link>/resource/%E6%8A%80%E8%83%BD%E4%B9%A0%E5%BE%97%E4%B8%8E%E6%8F%90%E5%8D%87/</link>
      <pubDate>Wed, 16 Apr 2025 20:35:23 +0800</pubDate>
      <guid>/resource/%E6%8A%80%E8%83%BD%E4%B9%A0%E5%BE%97%E4%B8%8E%E6%8F%90%E5%8D%87/</guid>
      <description>这段时间学习c++，主要看&amp;lt;c++ primer&amp;gt; &amp;lt;c++ primer plus&amp;gt;两本，在这个过程中，对技能习得有一些感悟。&#xA;新手入门最大的问题是不知道关注点，这样会导致看很多跟目标无关的资料，运气好的话一段时间后能梳理出该领域图景，运气不好可能需要很长时间。&#xA;所以好的教程会给一张大图，然后针对大图给几个抓手，就能基本入门，然后碰到什么场景就学哪些工具，效率高。&#xA;1 把该领域最权威的资料都翻了，关注点在哪也能出来，就是耗时间。&#xA;然后是技能的巩固和练习，练习的目的是增加熟练度，分为两层，一层是基础技能，比如写个tcp通信，写个基础的排序算法；第二层是对需求建模，看到目标，在心里盘算怎么把基础的东西组合，得到一个想要的结果。&#xA;具体操作：&#xA;2 模仿，需要通过模仿练手感，熟悉基础知识点&#xA;3 技能练习：让ai给出练习题&#xA;犯错触发反馈：&#xA;4 在训练的时候尽量用自己的语言去写，这样能暴露当前的理解和最好模型之间的gap，得到修正方向。&#xA;5 检测掌握情况：能否根据名字带出很多细节&#xA;6 检查是否理解：能否用自己的话说出来&#xA;可能空间，声明周期 闭环+验证 数据间的变化关系 用项目学习 目标不清晰 6 学习速度测算 一般只需要获取大图和抓手，每个小项做针对性练习，比如平均做两个吧，就能算出自己的学习速度，然后安排工作即可。&#xA;但学习是非线性的，一个知识点可能要间隔重复三遍才能完全掌握，碰到场景不全的情况会pending很久。&#xA;对此的策略是：&#xA;a 要留痕，原始资料，二次加工，得出的一些成果，都要留痕。&#xA;b 检查对材料的吸收程度，哪怕一篇很简单的文章深究也会牵扯到很多细节，看要探究多深。&#xA;c 检查自己的思维，如果大脑的概念和逻辑链，及自身的技能不能满足需求，说明这两块得继续扩展。&#xA;练习分为两种方式，一种是交互式的，一种是大脑中演练。熟练度由脑中相关的神经链路决定，可以想象最初的链路是文字、行为激活的，当链路成型后，只是在大脑中不断演练，也有很好的提升效果。&#xA;经过这么久的实践，目前理解学习就是压缩信息，确定一个范围，确定该范围所有的输入输出，用尽可能好的结构组织这些输入输出。所以习得有一个概念展开在收缩的过程。&#xA;进入任何一个领域，按照我上面说的找出该领域的知识结构，在知识结构的基础上找出行业最佳实践，就能躺着玩了。&#xA;学习&amp;ndash;&amp;gt;掌握阶段 状态1：完全陌生 看资料，补充逻辑 状态2：能想起几个名词，但还是陌生 看资料，补充逻辑，动手实践 状态3：能用基本要素写一些简单功能，但只能覆盖很小一部分场景 (间接经验)补充使用场景，在场景中反复折叠逻辑，反复动手实践 状态4：能完成功能模块，但限于项目，有些场景依然无法覆盖 (直接经验)寻找这些场景，学习开源项目 状态5：能完成需求，但是无法主导项目 主动获取资源，拿到经验包，直面需求 状态6：掌握20%的核心知识(反复折叠得到)，覆盖80%的场景，并能分析场景给出方案 封装知识复用 </description>
    </item>
    <item>
      <title>学习理论v1.0</title>
      <link>/resource/%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BAv1.0/</link>
      <pubDate>Sat, 15 Feb 2025 17:33:23 +0800</pubDate>
      <guid>/resource/%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BAv1.0/</guid>
      <description>参考 wxf blog/project/学习专题，之前的文章比较散，这一篇结合实践重新组织一下逻辑。&#xA;阅读顺序：&#xA;学习工程化 资料同步&#xA;学习工程化 搭建文档池及建立搜索入口&#xA;主题阅读方法&#xA;材料覆盖率&#xA;领域驱动+搭积木&#xA;这个话题不想再提了。&#xA;1 学习 ！= 阅读、刷课&#xA;学习是有目的性的把对方的概念空间转化成自己的，一个概念包含大量的细节，需要反复折叠才能摸到概念的边界&#xA;唯一重要的是思想，思想是看事物的视角，基于此视角形成概念空间。概念是信息的压缩&#xA;所以如果要检验是否看到真东西，就把概念还原成场景，忘掉概念&#xA;2 学习需要状态&#xA;如上提到的，如果今天很困，或者不是很想看书，效率会很低&#xA;第一点要确保精力充足，睡好、吃好、玩好，心无杂念，效率是最高的&#xA;第二点要确保随时进入状态，B=MAT&#xA;M很简单，热爱，能从中获得乐趣，或者说不得不学；T得设计，可以把两个动作串起来(行为链)，比如在GTD里面放数学题，或者埋几个外部触发的点(这两个都是很自然的触发器)；A的话需要降低行为过程中的阻力，需要：整块不被打扰的时间、笔记(留更多带宽给大脑思考)、实践平台&#xA;3 启发式学习&#xA;在工程实践过程中，更多的是没有方向。&#xA;效率最高的是问从业者，他们已经形成一套稳定的解决方案；第二是看源码；第三是阅读相关领域书籍、论文，穷举所有可能性，方案也就出来了(这个最怕的是视角不对，视角不对，很多概念出不来)&#xA;看源码或文献，从历史开始研究，效率最高&#xA;focus: 历史、已经出现的概念空间、各种影响因素&#xA;4 如何构建复杂逻辑&#xA;这个需要一个思维模型：一个框，所有遇到的概念或逻辑链丢到这个框里，等需要的时候再拿出来用。或者说时不时拿一两个出来做推演或观察(可能出现gap的情况)&#xA;要保证短逻辑链的稳固，需要在一个场景中能很纯熟的使用现有概念+工具解决问题&#xA;(类似于飞行员检查清单)、(这里建议看下《穷查理宝典》，有很多有用的工具)&#xA;ref git 飞行规则&#xA;在稳固的前提下扩展，尽量不影响原有逻辑。只要模型跟现实世界相符，偏底层，很少出现推倒重建的情况&#xA;5 实战流程&#xA;问题列表&#xA;问题&amp;ndash;&amp;gt;框定范围&amp;ndash;&amp;gt;资料搜集&amp;ndash;&amp;gt;断语拼凑&amp;ndash;&amp;gt;短逻辑链整理&amp;lt;&amp;ndash;&amp;gt;练习、维持手感&amp;ndash;&amp;gt;敲掉问题&#xA;资料搜集，参考“主题阅读”&#xA;断语拼凑，参考“文档池及搜索入口搭建”&#xA;短逻辑链整理，参考“demo，及开源代码阅读方法，简言之，先跑起来”&#xA;练习，参考“环境搭建”&#xA;现在特别喜欢工作里遇到不懂的问题，这意味着我当前的知识和问题之间，存在不少的gap点，我是这样“递归”来解决遇到的问题的： 1. 把遇到的问题一个个写下来，形成一个“问题列表”（list of problem），对问题的描述越具体越好； 2. 遍历第一步形成的“问题列表”，逐个解决。过程中记录、整理下来当前知识到解决这个问题之间，需要新增的知识点； 3. 第2步解决问题时如果同样遇到了问题，同样按照第一步的流程，把解决这个问题时遇到的子问题添加到“问题列表”里； 4. 重复以上三步，直到清空“问题列表”中的所有问题。 （附图中是这个流程的伪代码，但是不够准确，修改后的伪代码见评论） 四步下来之后，基本就完成了当前知识到问题之间，所有问题点的清理，以及新增知识点的整理。 知识点整理，需要落到具体的（文件）存储中，而不能仅仅局限于自己脑子里的“内存记忆”，而落到存储中需要有以下的要求： * 条理化、结构化； * 如果有可能，尽量增加图形化描述； * 时常回顾，确保每次回顾都能看懂以前的表述，如果没有就修改或者润色。 整个流程的重点是： * 把大的问题，划分成一个个的子问题，划分的标准是：是否能够解决这个子问题，如果不能就接着划分，让大的不能直接解决的问题“越具体越好”。 * 解决问题的过程中，把缺失的知识点整理补上，这样以后遇到类似的问题就能直接解决了。将原有的知识和新增的知识连接起来。 5 学习策略</description>
    </item>
    <item>
      <title>材料覆盖率</title>
      <link>/resource/%E6%9D%90%E6%96%99%E8%A6%86%E7%9B%96%E7%8E%87/</link>
      <pubDate>Fri, 13 Dec 2024 12:31:05 +0800</pubDate>
      <guid>/resource/%E6%9D%90%E6%96%99%E8%A6%86%E7%9B%96%E7%8E%87/</guid>
      <description>log:材料覆盖率章节增加材料索引相关内容&#xA;如何保证材料覆盖率？ 所有的东西都是为了满足某些需求，人为创造出来的，所以需要知道这套控制方案产生的驱动力是什么，在创造这一套控制框架的过程中，是如何选取组织材料的，有哪些取舍，效果如何，未来如何演化&#xA;降一层，自己构建出这个工具，(原子语言、基于原子语言构建的一个平台类的东西)&#xA;然后以该工具提供的接口为基础，在不同场景的应用；如何确保构建的程序可控(基于SDK，再做一层抽象，为了满足具体业务)&#xA;应用过程中出现的问题及排查措施、解决方案(补全2中的逻辑、工程漏洞)&#xA;最终得到的是一个不人为干预，完美运行的机器(理想状态)，事实上，没有完美的系统&#xA;材料覆盖率，说的就是材料中上面四个层次信息的覆盖情况。&#xA;step1: 因为信息都是人产出的，要么是网页形式，要么是书本，视频。&#xA;找该领域的20-30人，把他们产出的所有资料遍历一遍，这样做的目的是画一张大图，标几个关键点。&#xA;具体操作：搜索：电气设计 xxx，然后必然会搜出些书、知乎文章类似的，顺藤摸瓜，把里面提到的所有参考资料、人汇聚到一起，凑够30个，就大功告成了&#xA;实际操作：&#xA;ref 自定义搜索引擎&#xA;参考这篇文章，把平时索引搜集到的使用频率较高、内容质量相对比较高的网站放到google的自定义搜索引擎，可大大提升检索效率&#xA;ref 搭建个人文档池&#xA;实例：&#xA;在想办法解决qt界面自适应的时候，直接从google搜索，效率很低；在博客园搜，大概半个小时找到了解决方案。所以自定义搜索引擎可以加速从未知到已知的速度。&#xA;还有一个好处是可以不断积累，一切问题从已积累的材料入手，清晰划出了个人能力的边界，如果问题超出了能力圈，也知道怎么扩展能力圈。&#xA;还需要实践场景，解决的是从已知到熟练&#xA;step2: 无学习路径&#xA;通过各种方式搜集断语，用自己的话写下来&amp;ndash;&amp;gt;凑逻辑链&amp;ndash;&amp;gt;做练习，从不同角度检测逻辑链&amp;ndash;&amp;gt;淘汰没用的概念，成熟的闭环逻辑封存备用(注：可能需要花很长时间)&#xA;搜集断语路径：&#xA;技术文档 &amp;gt; 博客 &amp;gt;&#xA;2024/03/16 实践&amp;ndash;&amp;gt;技术文档&amp;ndash;&amp;gt;书单(扩充概念)&#xA;step3: 用工程手段探测，分析系统，找系统的控制点。这样相当于把视角切入到系统内部，有庖丁解牛，不见全牛的感觉。&#xA;依然是上面提到的四个层次，关注三个点：基本要素、抽象机制、组合机制。一个系统肯定能分解成最基本的部分。这里主要解决一个方向的问题，费曼有句话，凡我不能创造，我就不能理解。&#xA;如果step1的覆盖率足够的话，应该是能解决方向的问题，如果不行就求助有经验的员工，学习他们debug的思路，补全这块知识&#xA;2024/07/21 搜素proteus仿真相关书籍，内容有：所有功能介绍(当手册看)，经典电路，proteus构建仿真的思路及流程(此为上述覆盖率的一个实例)&#xA;2024/07/27 出现找一个资料死也找不到的情况，这时候要check下文档搜集路径(即网络)&#xA;2024/12/13 给出具体的索引方案，更新step1</description>
    </item>
    <item>
      <title>学习工程化2 搭建文档池及建立搜索入口</title>
      <link>/resource/%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%8C%962-%E6%90%AD%E5%BB%BA%E6%96%87%E6%A1%A3%E6%B1%A0%E5%8F%8A%E5%BB%BA%E7%AB%8B%E6%90%9C%E7%B4%A2%E5%85%A5%E5%8F%A3/</link>
      <pubDate>Wed, 13 Nov 2024 22:51:07 +0800</pubDate>
      <guid>/resource/%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%8C%962-%E6%90%AD%E5%BB%BA%E6%96%87%E6%A1%A3%E6%B1%A0%E5%8F%8A%E5%BB%BA%E7%AB%8B%E6%90%9C%E7%B4%A2%E5%85%A5%E5%8F%A3/</guid>
      <description>留存文档分类 1 保留最原始出处&#xA;2 分层组织，运用para规则，+article 学习工程化提到的第三点：构建自己的命名空间&#xA;3 检索历史也要保存到log文件，追加至留存文档&#xA;问题1： 建一个大文件夹，保存内容如下&#xA;简悦自动保存离线网页，丢进去&#xA;聊天记录定期导出，丢进去&#xA;使用频率较高的pdf，丢进去&#xA;md(我试了，可以展示图片，也可以用latex显示数学公式)或org格式写的笔记，丢进去&#xA;工程文件，丢进去&#xA;这样，基本所有的文档都汇到一个池子了&#xA;问题2：&#xA;这里主要是笔记和工程类文件&#xA;笔记以doc-area分类，比如doc-dianqi，doc-jixie，doc-front，doc-soft，doc-host，etc&#xA;工程类文件建pro文件夹，按项目分&#xA;检索 经过上面的操作，可以确保文件库大部分文件是文本格式，然后找一个文本检索工具，作为检索入口&#xA;recoll，它可以扫描这些文本文件，生成索引表，很快能检索出需要的文本信息&#xA;fix:2024/12/05&#xA;引入rga，scoop install rga，可以点对点搜索，命令行也更符合使用习惯&#xA;对学习和知识的看法 学习就是建模，跟之前提的构建逻辑链相似。穷举所有状态，让这些状态全部包含在构建的模型当中，就获得了对这个状态空间的控制力&#xA;最难的地方在确定最终状态、找出影响要素&#xA;假设观测到某种现象，这种现象受到三个要素影响，即使想到了这三个要素，也很难去验证&#xA;从0知识出发，建立复杂系统，注定有很长的路要走。&#xA;构建的这个叫pkm系统，它解决的是过往经验复用的问题，做时间的朋友。</description>
    </item>
    <item>
      <title>学习工程化</title>
      <link>/resource/%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%8C%96/</link>
      <pubDate>Fri, 01 Nov 2024 17:43:22 +0800</pubDate>
      <guid>/resource/%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%8C%96/</guid>
      <description>不知从何说起，首先说两个观察：&#xA;1 很多时候人是在不断重复自己，重复固定的行为模式 2 很多人在自己不熟悉的领域表现的很“慢”&#xA;基于此，我提出学习工程化的方法，以解决兴趣太广泛的问题。&#xA;流程：原始材料&amp;ndash;&amp;gt;加工&amp;ndash;&amp;gt;提取(适配场景)&#xA;在遇到具体场景的时候，我发现很多知识点提取不出来，三个原因：&#xA;1 不能即时接触(行为设计角度来讲，阻碍越大，行为就越小几率出现)&#xA;2 加工后的材料应该结构化，形成一组组完整的概念空间&#xA;3 已经经历的场景生成的概念空间应该保存，以便后期复用&#xA;做一套机制，解决上述三个问题，就能不间断学习，且学习速度越来越快。&#xA;问题1，我的解决方式是:&#xA;md文档归纳知识点，坚果云同步至不同设备，docsify建站分享 问题2，我的解决方式是通过反复折叠，跑通流程，并将关键点记录在上述md文档中，文档归类完毕，应用频率高的知识点往文档顶部走，时间一长，使用频率高的知识点就都顶到头部了。&#xA;问题3，我觉得很有必要形成自己的名称空间，你得想办法去实现这些名字代表的具体内容，并将其固化。 bash脚本实现书签管理&#xA;通过bash脚本接管所有操作。或者一直建立并维护资源类通道&#xA;我的常用名称空间大概这样 通过上述三个动作，就能把除了材料加工，场景外的所有内容都交出去。&#xA;在没有场景的时候可以通过材料加工构建逻辑链，有场景的时候直接提取，完善修正。&#xA;这是操作流程化，涉及到数学知识，计算类的，也要固化成概念，碰到具体场景直接使用做好的概念就成。&#xA;end</description>
    </item>
    <item>
      <title>贝叶斯推理</title>
      <link>/resource/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%8E%A8%E7%90%86/</link>
      <pubDate>Thu, 10 Oct 2024 07:18:18 +0800</pubDate>
      <guid>/resource/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%8E%A8%E7%90%86/</guid>
      <description>贝叶斯推断最关键的点是可以利用贝叶斯定理结合新的证据及以前的先验概率，来得到新的概率（这和频率学派推断相反，频率论推断只考虑证据，不考虑先验概率）。&#xA;而且贝叶斯推断可以迭代使用：在观察一些证据后得到的后设概率可以当作新的先验概率，再根据新的证据得到新的后设概率。因此贝叶斯定理可以应用在许多不同的证据上，不论这些证据是一起出现或是不同时出现都可以，这个程序称为贝叶斯更新（Bayesian updating）。</description>
    </item>
    <item>
      <title>干掉拖延&#43;产出导向</title>
      <link>/resource/%E5%B9%B2%E6%8E%89%E6%8B%96%E5%BB%B6&#43;%E4%BA%A7%E5%87%BA%E5%AF%BC%E5%90%91/</link>
      <pubDate>Fri, 31 May 2024 12:27:10 +0800</pubDate>
      <guid>/resource/%E5%B9%B2%E6%8E%89%E6%8B%96%E5%BB%B6&#43;%E4%BA%A7%E5%87%BA%E5%AF%BC%E5%90%91/</guid>
      <description>开头 为了提升做工程的效率，对标题说的两点做诠释，希望能帮助自己提升。&#xA;为什么拖延不好 摘录《目标》中的一段。高德拉特是以色列物理学家，著名的生产专家，其TOC(theory of constraint)理论大幅提升了工厂的生产效率。&#xA;假如我们的最终目的是产出，在产出之前会经过一系列步骤，看看这些步骤是怎么影响产出的。&#xA;健行： 发现队伍行进速度跟预期不一致: 注意到最直接影响因素： 提取要素： 注意到另一个直接影响因素： 抽象模型： 通过火柴游戏揭示拖延导致有效产出降低：&#xA;游戏规则： 游戏结果: 拖延带来的有效产出降低： 结论：瓶颈决定有效产出 产出导向 所以需要发现自己工作流程中的约束点，一个一个敲掉。对于我来说，最大的约束点可能是对新知识的消化吸收速度，以及设计完获得反馈的速度，这两个依赖于对领域底层知识(原理性的、工程性的)的熟悉程度，以及用外界构建资源去搭建一个模拟环境，来测试逻辑链。&#xA;后续得想办法加强这两块。</description>
    </item>
    <item>
      <title>软硬件调试九法</title>
      <link>/resource/%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95/</link>
      <pubDate>Wed, 22 May 2024 21:02:15 +0800</pubDate>
      <guid>/resource/%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95/</guid>
      <description>在公司做了四天电工，接了四天线，突然顿悟，于是翻出这本珍藏已久的《软硬件调试九法》，作者无疑是个有大量调试经验的高手工程师，本文摘出重点。&#xA;概览 在调试系统前，要坚定一个信念，系统存在一个稳定状态，而且经过各种手法，一定能把系统调试至稳定状态。&#xA;如果迟迟达不到理想状态，一定是对系统不够了解&#xA;这个了解有三个方向：分解系统的颗粒度、观察范围、探测系统的工具。&#xA;颗粒度是指把系统细分到什么程度，比如一套低压电器系统，刚开始只需关注配电；如果这个层面解决不了问题，细分到具体低压元器件；再往下，关注电气控制信号、网络信号(这两个比较难观测，需要制作相应工具)。&#xA;观察范围也好理解，看过城阳电工视频的人应该有直观感受，本来是一个空调漏电的事，最后排查到电线杆子上的配电箱。系统出现问题有可能是外界环境导致的，而很多人在调试的时候只是盯着系统本身。&#xA;拿到一个新东西，如果有说明书、demo之类的东西，先跑一跑，建立直观印象。然后我就思考，假如我要实现另外一种功能，可以拆解哪些要素出来，怎么观测这些要素，怎么组合这些要素。&#xA;书本逻辑 以上面三条为主线，摘出我感兴趣的内容(一个小标题代表一个调试规则)：&#xA;理解系统&#xA;方法：阅读手册、知道什么是正常的、知道工作流程、了解你的工具、查阅手册&#xA;制造失败&#xA;方法：引发失败、不要模拟失败、如何处理间歇性bug、如果做了所有尝试之后问题依然间歇性发生、那不可能发生、永远不要丢掉调试工具&#xA;真实生产环境用控制变量法，找出导致问题的要素&#xA;间歇性bug可能是动作序列引起的，跟状态有关系，这时候要对系统的各个组件做状态推演&#xA;失败肯定有原因，一定能找出来，目前找不到是因为其“巧妙地”隐藏在尚未发现的大量随机因素背后&#xA;不要想，而要看&#xA;不要让仪器影响了系统，仪器引入会使系统发生变化，但可以想办法隔离引入的影响&#xA;动手测试猜想的正确性&#xA;分而治之&#xA;上文说的颗粒度也有帮助快速排查的作用，比如确定问题出在这个子系统，只细分探索确定有问题的子系统即可&#xA;一次只改一个地方\&#xA;保持审计跟踪&#xA;记录调试过程中的所有操作，也许能发现新的关联项&#xA;检查插头&#xA;怀疑任何假设，比如我用软件没探测到需要的数据吗，那有没有可能是工具本身的问题。或者我认为某个地方是绝对不会出问题的，问题可能正好是那边产生的。&#xA;寻求帮助&#xA;ref &amp;lt;软件开发者路线图-组织知识来源&amp;gt;&#xA;如果你不修复bug，它将依然存在&#xA;确定bug得到解决，修改设计文件，从根源杜绝bug的产生&#xA;结尾 我觉得没什么说的，这都是常识。相比于调试思路，最重要的反倒是动手实践。</description>
    </item>
    <item>
      <title>主题阅读方法</title>
      <link>/resource/%E4%B8%BB%E9%A2%98%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 14 May 2024 08:11:56 +0800</pubDate>
      <guid>/resource/%E4%B8%BB%E9%A2%98%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95/</guid>
      <description>主题阅读首先要扩充样本库，然后从样本库里找跟自己目标相关的内容&#xA;annas-archive，是一个开源书籍项目，里面存了各种渠道得来的两千多万本书，先挑出所有相关书籍，然后复制粘贴也好，ocr识别也好，手写也好，把所有目录抄一遍。差不多抄到20本书的时候，能对整个主题的脉络有把握，剩下的就是攻破细节了！！！&#xA;log: 20240620:配套相关设施，安卓+阅读软件，+京东读书，+微信读书，+calibre-web，pc +logseq，接下来看实际运行效果&#xA;20240621:淘宝、拼多多搜素也能找到一些线索&#xA;20250320:比如python，有些人已经完成了python的学习，并将资料聚集到一起，找到这些资料可以保证覆盖率，（这是一种取巧的方法）&#xA;skills:&#xA;1 通过各种渠道搜书，汇集到一起&#xA;2 翻书，翻到有兴趣的点截图保存&#xA;3 每周翻一本&#xA;4 将截图的内容手打一遍，并分类保存</description>
    </item>
    <item>
      <title>超越理论-情景创设</title>
      <link>/resource/%E8%B6%85%E8%B6%8A%E7%90%86%E8%AE%BA-%E6%83%85%E6%99%AF%E5%88%9B%E8%AE%BE/</link>
      <pubDate>Wed, 08 May 2024 09:12:54 +0800</pubDate>
      <guid>/resource/%E8%B6%85%E8%B6%8A%E7%90%86%E8%AE%BA-%E6%83%85%E6%99%AF%E5%88%9B%E8%AE%BE/</guid>
      <description>从这两天的经历说起吧，从0开始写s7-200 smart plc程序，过程如下：&#xA;我先找手册找出自认为重要的点，然后用单元测试拆解别人的程序，拆解过程中发现了自己很多盲区，然后结合手册和其他人的程序攻破盲区。&#xA;在攻破盲区的过程中，最常见的一个问题是没线索，找不到方向(逻辑闭包)；第二个问题是思路闭环了，却没办法验证(环境)；第三个问题是具体操作层面，涉及到很多细节，不自己跑一遍流程就很难受(工程实践)&#xA;看一下产品是怎么完成的:&#xA;我写程序（大部分是平台级软件，比如bootload，OS，驱动，中间件等。但如果是UI，可能我会省略其中一些步骤）的过程是这样的：&#xA;先写基础逻辑&#xA;进行逻辑优化&#xA;在所有逻辑不straightforward的，或者对不太可靠的库的输入有要求的地方，一概加上ASSERT()&#xA;在所有在运行中不会引起性能瓶颈的执行分支上都加上性能统计参数&#xA;单元测试 集成测试（通常集成到单机一级）&#xA;系统测试，战地测试（这时重点关注所有的性能统计参数，看现网条件下，程序是否按预期运作）&#xA;下一个开发循环，复用上一次的单元测试用例&#xA;通常我的程序在单元测试后，逻辑错误几乎为0，剩下都是同步，性能一级的错误了，而且，我可以很得意的说，我的程序在数百万乃至上千万个节点上运行，能反馈回来给我的错误也是少之又少的。&#xA;这是商业产品开发的样子&#xA;基于上述两段话，可以0知识，即使是一个小白，也能很快打通从技术到产品的整个流程，还差一个市场端(不在本文范围)。初始阶段只能通过拆解别人的程序补盲区，积累设计方法，后续开始设计同类型产品，技巧积累的差不多就能自己主导设计了。&#xA;可以看出，每一步都是难点。我主要卡在环境和工程实践上，难道除了进公司，借助外部环境外就没别的办法了吗？望指点。</description>
    </item>
    <item>
      <title>学习本质</title>
      <link>/resource/%E5%AD%A6%E4%B9%A0%E6%9C%AC%E8%B4%A8/</link>
      <pubDate>Thu, 11 Apr 2024 23:12:18 +0800</pubDate>
      <guid>/resource/%E5%AD%A6%E4%B9%A0%E6%9C%AC%E8%B4%A8/</guid>
      <description>哪有什么学习本质，坐而求道，不如行之。&#xA;也许我是困在“求本质”这个“名”中太久了。&#xA;20240602&#xA;补充一点，学习是为了快速解决问题，分三层，第一层我解决了从0到1的问题；第二层得补充领域知识做缓存，达到快速提取的目的；第三层就是结合具体场景快速给出框架或者敲掉问题。&#xA;借用之前《软硬件调试九法》里的话，问题的出现是因为对系统不了解造成的，一定能调试出稳定的系统</description>
    </item>
    <item>
      <title>领域驱动&#43;搭积木</title>
      <link>/resource/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8&#43;%E6%90%AD%E7%A7%AF%E6%9C%A8/</link>
      <pubDate>Tue, 02 Apr 2024 00:47:41 +0800</pubDate>
      <guid>/resource/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8&#43;%E6%90%AD%E7%A7%AF%E6%9C%A8/</guid>
      <description>说说我是怎么学习c语言的。&#xA;我认为c语言是构建出的工具，为了使用好这个工具，得往下降一层，去学习编译器相关原理，但是也不用学的太多，有这么一张表足够，上面写了基本元素和语法规则、语义，此两者相当于象棋规则。&#xA;知晓规则后便是为了实现我们的目标，精心编排代码段。编排代码段跟搭积木类似，不管多复杂的逻辑，最终要回到这些基本要素，要做的是把相关的逻辑链跑通，然后看看人家是怎么搭积木的，用自己的方式实现一遍。&#xA;如此不断遍历，学会编程只是时间问题。但是，我在网上看到的c语言教学，都是教着写语句，++循环，乱七八糟的，那玩意用教么，给个表照着写不成吗，误人子弟 第二种是领域驱动，因为代码反映现实，跟具体领域相关，只有对编程的理解还不够，需补充领域相关知识，这时候需要请领域专家，一起建模，直到模型跑通了，产出产品为止。</description>
    </item>
    <item>
      <title>快速学习 终篇</title>
      <link>/resource/%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0-%E7%BB%88%E7%AF%87/</link>
      <pubDate>Sun, 10 Dec 2023 11:30:18 +0800</pubDate>
      <guid>/resource/%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0-%E7%BB%88%E7%AF%87/</guid>
      <description>学习的目的是为了解决问题，我来讨论学习成果及有效性。&#xA;首先得定义范围，问题、解决问题所需要的知识，均需定义范围。&#xA;探索过程：从图中你的位置出发，有很多可能方向，你得把这些虚线描述的错误方向排除(要求自己动手测试)。如此反复，最终得到整个知识网&#xA;名称空间 自我探索要求我们有一定的“抽象”和“细节”能力&#xA;抽象可以帮助我们隔绝，控制复杂度，更快的掌握某个知识&#xA;细节可以敲碎黑盒，让我们一窥黑盒内部的究竟&#xA;善用这两个工具，可以帮助我们得到一个系统的，成体系的知识，也可以指导我们探索缺乏研究的领域，更好更快的探索未知&#xA;20241003：直接从细节出发，将对方的概念空间替换成自己的，这样就完成了知识的内化(ps.这个这个理解更具实操性)&#xA;复用过程：得保证知识网可靠，用到逻辑闭包的概念 </description>
    </item>
    <item>
      <title>关键点</title>
      <link>/resource/%E5%85%B3%E9%94%AE%E7%82%B9/</link>
      <pubDate>Fri, 24 Nov 2023 19:31:30 +0800</pubDate>
      <guid>/resource/%E5%85%B3%E9%94%AE%E7%82%B9/</guid>
      <description>展示一些快速学习实践过程中抓到的关键点及硬限制。&#xA;材料是否充分 对材料的消化吸收是否到位 模型是用来帮助思考的，所以除去理论，肯定有一些工程手段帮助验证对系统运行情况的了解&#xA;通过工程手段建立对事物的直觉&#xA;提取练习：&#xA;场景&amp;amp;系统设计、调试过程？&#xA;反馈：标准答案纠错&#xA;2024/06/04 最快速的方法就是从现场获得反馈。最重要的一点，基础一定要牢固，不然现场解决问题很慢的!!!&#xA;卡顿及如何提速 卡顿是因为逻辑存在不清晰部分，检查是否所有底层概念都理解透了(用自己的话写出来)，概念的组合层次关系划分是否正确(即是否是一块块的闭环逻辑)&#xA;20250208 但是存在一些非标的东西，找不到线索&#xA;答案就是穷举和寻求外界帮助，除非经过特别精心的设计，工具、思维都有漏洞，所以流程跑不通很正常，要有毅力&#xA;很多事情都是可以穷举出来的 如何确定终点 20250208 到达理想状态可以认为到达终点&#xA;以开源项目为例，比如MFC框架，很久都没更新，说明目前的架构满足需求&#xA;QA 快速进入状态&#xA;溺水法：直接丢进场景，在场景摸索&#xA;有学习路径&#xA;逻辑链是现成的&amp;ndash;&amp;gt;做练习，从不同角度检测&amp;ndash;&amp;gt;封存备用&#xA;卡顿及如何提速&#xA;卡顿是因为逻辑存在不清晰部分，检查是否所有底层概念都理解透了(用自己的话写出来)，概念的组合层次关系划分是否正确(即是否是一块块的闭环逻辑)&#xA;如何快速摸清楚认知边界&#xA;用自己的话说，说不清楚就是这一块存在盲区&#xA;如何快速拓展知识边界&#xA;搜集外界线索&amp;ndash;&amp;gt;写断语&amp;ndash;&amp;gt;xxx&#xA;搜集线索方法：知乎等类似网站提问&#xA;如何内化吸收&#xA;做练习，从不同角度检测概念或逻辑链，确定其内涵和外延&#xA;逻辑链条很长怎么办&#xA;只能从基础开始一点一点推，欲速则不达，采取的策略：对实现目标有帮助的优先&#xA;怎么确定某知识效果&#xA;提假设&amp;ndash;&amp;gt;构建观察指标&amp;ndash;&amp;gt;验证，这里存在负反馈循环。&#xA;怎么构建观察指标呢？凭经验、或者该关键词关联的其他线索，进行广度优先遍历，确定大体方向，再做深度优先遍历&#xA;怎么快速构建长逻辑链&#xA;偷其他人的逻辑链，看他们面对问题怎么找线索，怎么选择方向，怎么检测，怎么做练习，怎么解决问题&#xA;Log:&#xA;想靠看文档学会，这个不现实，有三个层次的“学会”，建模、实践摸到边界、补全概念空间，xxx&#xA;任务分解及解决：xxx 急于求成，基础不牢&#xA;缺少了一点勇气，和决心 目标+勇气&#xA;面对一大片知识怎么办：一点一点攻克，抓重点&#xA;Ai当搜索引擎用，不要指望给出好的解决方案&#xA;小步迭代：贝叶斯方法 | 榨干资料、或者项目的所有信息&#xA;抓大放小&#xA;单纯记载知识没用，要实战&#xA;知识点：分支预测的方法 建模：正交&#xA;哪些东西重要，不能光靠想象或者阅读；实践，通过项目找关注点；；光靠阅读找不到重点&#xA;还有一种办法是先实践(实践也得先看资料，构建一个初始的概念空间，然后用手段去检测)，实践过程中会遇到很多疑问，带着疑问找线索，理清逻辑，封存；；&#xA;知行合一： 知和行之间有gap，行涉及到很多细节的判断，知只需要缕清逻辑&#xA;学习： 记忆与信息编码方式&#xA;渐进式阅读：&#xA;知识不足以覆盖目前场景； 学到的知识一定能覆盖目前场景吗？？？？，或者说怎么才能达到让知识能覆盖目前场景的状态&#xA;缺少现实世界的触发&#xA;工具手册怎么组织：xx&#xA;技术栈本身，do it，面对问题，解决问题&#xA;抓住一切机会去争取调度资源</description>
    </item>
    <item>
      <title>Ref 学习</title>
      <link>/resource/ref-%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Tue, 21 Nov 2023 14:10:27 +0800</pubDate>
      <guid>/resource/ref-%E5%AD%A6%E4%B9%A0/</guid>
      <description>再谈什么是软件架构&#xA;我手上有无数这种分析，一般我会写在evernote上，但前天正好在机场等飞机，写的时候手边访问evernote不方便，所以就改写到知乎上了。 我举这个例子是说，其实架构师手边是有大量的分析数据的，但必须能保证这些分析不会随意进入主分析链，避免目标被冲淡了。所以，你看到一点点的决策或者判断，实际上可能背后都是大量的工作。&#xA;就是要你懂TCP&amp;ndash;半连接队列和全连接队列就是要你懂TCP&amp;ndash;半连接队列和全连接队列&#xA;20240907 重读，作者确实对基础知识敲的比较深\&#xA;如何在工作中学习&#xA;快速学习&#xA;什么是软件架构&#xA;浅谈最佳学习路径&#xA;Makefile概念入门&#xA;20240421 重读，为了更高的控制力，make工具一直在演化，最终给出一套完整的工程文件编译规则，适配所有平台。高屋建瓴，最重要的是“基于目标分层”的方式理解一个工具的思维，太牛逼了\&#xA;如何快速学习一项新技能？&#xA;如何学习一门技术&#xA;一款产品的从0到1之旅&#xA;从技术难题中学习&#xA;为什么在现实中学到的知识和观点，我自己无法成体系遵从逻辑得表达出来？&#xA;世界观和方法论&#xA;+The &amp;lsquo;illusion of knowledge&amp;rsquo; that makes people overconfident&#xA;//学会的&amp;quot;幻觉&amp;quot;&#xA;黑客的学习方法&#xA;099 高效学习：面对枯燥和量大的知识&#xA;SuperMemo 渐进学习大型指北</description>
    </item>
    <item>
      <title>关于学习的思考</title>
      <link>/resource/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Fri, 18 Aug 2023 18:35:09 +0800</pubDate>
      <guid>/resource/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>为什么要学习 学习就是为了解决问题，绝学无忧&#xA;学习流程 知识留存率： 流程： 方法（基于思维状态）（概念性学习）：&#xA;从学习开始的时候，就要开始整理自己的逻辑，让你的知识有一个“框架”可以依附，否则你会一直是离散的状态。 但不要指望你的框架一开始就是完善或者对的，只要有效把你当前的认知总结出来就好，甚至只花10分钟的时间都可以，因为没有细节去填充，你花的时间越多，你就越被自己迷惑了。 然后开始看教材，修正你原来的逻辑框架，这种修正，既可以是对框架整个认识的修正，也可能是对框架“断语”的修正。比如，你一开始认为立体几何是“计算体积的几何”，后来看到细节后，发现它是计算线性三维空间中位置关系的几何，你可以调整你原来的范围定义。你一开始“断言”：理解一个立体形状，需要找到一些和视线垂直的面才能获得那个面的真正长度。但后面你在教材中找到了从任意切面计算非垂直切面的计算方法，这个断言可以改变或者进行补充。 当教材中，或者我们生活中，实验中，你发现和你的框架不符的东西，作为一个和逻辑不一致的断言记录下来，它们就像当初说的“物理大厦的最后两朵乌云”一样，会成为你更进一步的关键逻辑的。这一点很重要：不要为了模型的完美，而拒绝对事实的认知。是事实定义模型，而不是模型定义事实。 用自己的语言或者典型例子重新描述教材的概念，好记比严谨更重要，因为这可以是两件事：用你好记的语言记住概念，然后用严谨的表述去解决问题，这不需要统一在一起的。 在自己重新描述教材概念的时候，尽量和教材的概念不一样，尝试用“其实就是XXXX嘛”这种方法去表述它，这样能让你最终明白教材为什么要那样定义。 不要指望模型可以取代细节知识和经验，模型知识帮助你整理知识，让你快速发现知识细节，它不能取代你去不断学习和实习细节知识。模型只属于你自己，其他人看你的抽象，也学不会你掌握的知识；反过来，你看别人的总结，可能对你有所帮助，但一定无法取代你本身去学习那些细节，所以，反复实习，反复刷题，仍是你进一步学习进去的必要条件，那是不可取代的，但模型可以避免你无效刷题，刷了半天一点进步没有。 生理学（神经可塑性）：&#xA;细节参考文章，我拿出粗略的框架。&#xA;神经系统是可变的，25岁前，这种变化主要是去除不符合目标的连接过程(突触连接形成的神经网络)；25岁后，必须经过一系列步骤来改变内部状态，以使得能够改变你的大脑。&#xA;神经系统有两个广泛的功能集，一些是反射性的，比如呼吸、心率，行走。当我决定改变某种行为，某种反应，需要将它带入我们的意识，这种意识提示大脑和其他神经系统，未来参与这些反射性行为时，这些反射性行为需要特殊处理。所以神经可塑性第一步是意识到你想改变某些东西。&#xA;当我们有意识地想要做一些改变，我们的前脑，特别是前额叶皮层，会向神经系统发出信号，告诉我们注意到这里即将发生的东西、感受或体验是值得关注的。当仔细关注时，大脑会从不同地方释放神经化学物质，跟神经可塑性紧密关联的：肾上腺素、乙酰胆碱&#xA;表皮素：从大脑中释放的肾上腺素我们称之为表皮腺素，从肾上腺腺体释放的称之为肾上腺素，两者是同一类化学物质。&#xA;表皮腺素从脑干的蓝斑区域释放，蓝斑通过轴突的小线发送，将大脑用神经化学物质表皮腺素冲刷(只有高度警觉的时候才会释放表皮腺素)，它会使大脑变得很警觉。但获得可塑性的关键是同时存在表皮素和乙酰胆碱 乙酰胆碱：脑干有一个区域，丘脑，不断接受来自各种感觉输入，过滤向上发送信号。当我关注某件事时，我会产生一个关注锥，生理层面是乙酰胆碱正在增强我关注部分的信号。所以表皮素用来警觉，乙酰胆碱用来聚焦这些输入。 前脑区域：该区域应该是引导形成神经链接？该区域释放乙酰胆碱，进一步整理过滤完一次的信号，引导形成新的神经链接 所以现在，加大对这三个部位的刺激，就可以获取快速学习的能力，用电极插进大脑，放电刺激。&#xA;原理性层面解释完了，具体到操作层面。第一步是，如何创造深度专注。我们有物理工具、药物、行为工具。&#xA;考虑行为工具，大脑的注意力与我们的视觉系统有关，当我们眼睛稍微内向移动以对准特定的视觉目标时，我们的视觉世界缩小了，视觉聚焦水平提高，这是因为大脑中可塑性相关的区域的乙酰胆碱和肾上腺素的释放导致。对于听力学习导向的人，他们会闭上双眼，创造一个听觉注意力力锥。&#xA;也可以通过激励、恐惧、爱等心理技巧，或者药物增加警觉，但是注意力还是得靠听觉、视觉来聚焦。&#xA;要注意，典型的学习过程顶多持续90min，且一天顶多进行3-4次有效学习过程。学习完一个周期，需要结合睡眠让新形成的神经序列自动巩固，可以小睡，也可以冥想，还有去散步，冥想和散步属一种特殊的非睡眠深度休息模式。&#xA;生理学(运动学习)：不涉及&#xA;提高效率 综上，既然学习的目标是解决问题，那就看看我们如何解决问题：&#xA;意识到问题&amp;ndash;&amp;gt;界定问题&amp;ndash;&amp;gt;寻找线索&amp;ndash;&amp;gt;提出解决方案&amp;ndash;&amp;gt;执行方案&amp;ndash;&amp;gt;返回3、4步(重复)&amp;ndash;&amp;gt;解决问题。所以学习的核心在3、4、5、6步，有没有办法可以加速这个过程呢？&#xA;我寻找线索的方法是问搜索引擎，有些人喜欢问人。搜索引擎就是把关键词相关的网页抓过来，如果其他人解决过同类问题并文字化或视频化，我就能参照他的经验解决问题。&#xA;现在出现chatgpt，它可以解析自然语言，给出相应的解决方案，无疑降低了搜索引擎的使用门槛。&#xA;有一种可能，我们已经看过相关材料，但是并没有深刻理解，等到几年后碰到类似的问题，又重新查资料，我的做法是保存这些材料，用recoll搜索关键字，大大加速寻找线索的过程。我自己写的东西也加入到被搜索材料，这样可以保持一个增量的知识库，减少动用搜索引擎的次数(搜索历史也要加入被搜索文件：recoll的搜索历史，搜索引擎的搜索历史)。&#xA;如果提不出解决方案，说明缺乏前置知识，需要补充知识库，引入一些新概念。通过搜索引擎或问人来找线索&#xA;执行方案最重要的是条件是否具备，需要调动资源，搭建环境，然后才能验证解决方案。在我们生活中，会频繁用到某些环境，比如开发环境，工作环境，这类环境的设计和维护就很重要。比如我之前提到的：电脑环境的无缝迁移、地理环境的无缝迁移、工作环境的无缝迁移。&#xA;具体的搭建过程，肯定要集齐一组相互依赖的资源，且要维持这个环境存在一段时间。资源，有的话直接用，没有的话找人交换，如果可以复用其他人的资源，成本最低，就酱&#xA;返回3、4步，最好有一个纠错机制，比如错题本，记录下解决同一类问题每次卡壳的地方，形成一张清单。&#xA;具体下面链接提到了：&#xA;泛化目标(孤立使用指令和归纳学习) 材料瓶颈(没搞清楚前置知识，返回去搞清楚不清楚的知识点) 模型瓶颈(先用实例型材料构建感知，再解除描述性材料) 无效训练(对有效材料进行完正的有效训练；对指令性材料进行精细加工，扩充新例子，与旧知识建立联系) 成果测试(一定要提供回溯方向，提供原始材料的上下文) 知识验证(输出，我这篇文章就是) 巩固学习成果 我的个人成长管理体系里有一个产出成果管理，成果管理分为两部分：学习成果、项目成果，学习成果包括思维和生产力。我想解答学习成果的产出是什么，以下是我的思考：&#xA;什么是产出成果？&#xA;这个跟目标相关，所有对推进实现目标有帮助的，都算有效产出成果； 不管是选题，路径探索，通道建设，调整前两者，获取成果 怎么衡量呢？ 我在日复盘加一句吧：今天的产出成果是什么？&#xA;0811&#xA;注意产出成果的复用&#xA;0818&#xA;每天的关注点就是产出成果，得设计一套系统让产出成果留存&#xA;0819&#xA;产出成果留存，第一种方式是文字，可以通过recoll调取，反正我记录了整个过程，调取的时候能带出相关上下文。&#xA;第二种是我搭建的程序，如《播客转移方法》中提到的，那些bash脚本，网站服务，就是我的产出成果。&#xA;思维的改变是一个很不直观的事，只能通过分析这些留存的资料，你可以维持一张列表，一些需要持续关注的问题，隔两三个月拿出来，看看有新思路木有，有的话可以追溯留下的资料，寻找新思维的起点。&#xA;ref_src in nek 快速学习&#xA;学习观 断墨寻径&#xA;how to focus to change your brain_ the humab lab</description>
    </item>
  </channel>
</rss>
